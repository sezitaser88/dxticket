import React, { useRef, useEffect } from "react";

import { TYPE_MANAGE_CONTENT_BUTTON, TYPE_MANAGE_MENU_BUTTON, TYPE_CONTAINER_UNORDERED_LIST, TYPE_CONTAINER_ORDERED_LIST, TYPE_CONTAINER_NO_MARKUP, TYPE_CONTAINER_INLINE, TYPE_CONTAINER_ITEM_UNDEFINED, isContainer, isContainerItem, initialize, destroy } from "@bloomreach/spa-sdk";

/**
 * The React Context holding the current brXM Component.
 */ const BrComponentContext = React.createContext(undefined);

function BrMeta({children, meta}) {
    var _a;
    const head = useRef(null);
    const tail = useRef(null);
    useEffect((() => {
        var _a;
        if (!((_a = head.current) === null || _a === void 0 ? void 0 : _a.nextSibling) || !tail.current) {
            return undefined;
        }
        return meta.render(head.current.nextSibling, tail.current);
    }), [ meta, (_a = head.current) === null || _a === void 0 ? void 0 : _a.nextSibling, tail.current ]);
    return React.createElement(React.Fragment, null, meta.length > 0 && React.createElement("span", {
        style: {
            display: "none"
        },
        ref: head
    }), children, meta.length > 0 && React.createElement("span", {
        style: {
            display: "none"
        },
        ref: tail
    }));
}

/**
 * The React Context holding the current brXM Page.
 */ const BrPageContext = React.createContext(undefined);

const BrMappingContext = React.createContext({});

class BrNodeComponent extends React.Component {
    getMapping() {
        return this.context[this.props.component.getName()];
    }
    render() {
        const mapping = this.getMapping();
        const meta = this.props.component.getMeta();
        const children = mapping ? React.createElement(mapping, this.props) : this.props.children;
        return React.createElement(BrMeta, {
            meta
        }, children);
    }
}

BrNodeComponent.contextType = BrMappingContext;

function BrContainerBox({page, children}) {
    return React.createElement("div", {
        className: page.isPreview() ? "hst-container" : undefined
    }, React.Children.map(children, (child => React.createElement("div", {
        className: page.isPreview() ? "hst-container-item" : undefined
    }, child))));
}

function BrContainerInline(props) {
    const {page, children} = props;
    return React.createElement("div", {
        className: page.isPreview() ? "hst-container" : undefined
    }, React.Children.map(children, (child => React.createElement("span", {
        className: page.isPreview() ? "hst-container-item" : undefined
    }, child))));
}

function BrContainerNoMarkup({children}) {
    return React.createElement(React.Fragment, null, children);
}

function BrContainerOrderedList({page, children}) {
    return React.createElement("ol", {
        className: page.isPreview() ? "hst-container" : undefined
    }, React.Children.map(children, (child => React.createElement("li", {
        className: page.isPreview() ? "hst-container-item" : undefined
    }, child))));
}

function BrContainerUnorderedList({page, children}) {
    return React.createElement("ul", {
        className: page.isPreview() ? "hst-container" : undefined
    }, React.Children.map(children, (child => React.createElement("li", {
        className: page.isPreview() ? "hst-container-item" : undefined
    }, child))));
}

function BrContainerItemUndefined({component}) {
    return React.createElement("div", null, `Component "${component.getType()}" is not defined.`);
}

/**
 * The button component that opens for editing a content.
 */ class BrManageContentButton extends React.Component {
    render() {
        const {context} = this;
        return (context === null || context === void 0 ? void 0 : context.isPreview()) ? React.createElement(BrMeta, {
            meta: context.getButton(TYPE_MANAGE_CONTENT_BUTTON, this.props)
        }) : null;
    }
}

BrManageContentButton.contextType = BrPageContext;

/**
 * The button component that opens a menu editor.
 */ class BrManageMenuButton extends React.Component {
    render() {
        const {context, props: {menu}} = this;
        return (context === null || context === void 0 ? void 0 : context.isPreview()) ? React.createElement(BrMeta, {
            meta: context.getButton(TYPE_MANAGE_MENU_BUTTON, menu)
        }) : null;
    }
}

BrManageMenuButton.contextType = BrPageContext;

class BrNodeContainer extends BrNodeComponent {
    getMapping() {
        const type = this.props.component.getType();
        if (type && type in this.context) {
            return this.context[type];
        }
        switch (type) {
          case TYPE_CONTAINER_INLINE:
            return BrContainerInline;

          case TYPE_CONTAINER_NO_MARKUP:
            return BrContainerNoMarkup;

          case TYPE_CONTAINER_ORDERED_LIST:
            return BrContainerOrderedList;

          case TYPE_CONTAINER_UNORDERED_LIST:
            return BrContainerUnorderedList;

          default:
            return BrContainerBox;
        }
    }
}

class BrNodeContainerItem extends BrNodeComponent {
    constructor(props) {
        super(props);
        this.onUpdate = this.onUpdate.bind(this);
    }
    componentDidMount() {
        this.props.component.on("update", this.onUpdate);
    }
    componentDidUpdate(prevProps) {
        if (this.props.component !== prevProps.component) {
            prevProps.component.off("update", this.onUpdate);
            this.props.component.on("update", this.onUpdate);
        }
    }
    componentWillUnmount() {
        this.props.component.off("update", this.onUpdate);
    }
    getMapping() {
        var _a;
        const type = this.props.component.getType();
        if (type && type in this.context) {
            return this.context[type];
        }
        return (_a = this.context[TYPE_CONTAINER_ITEM_UNDEFINED]) !== null && _a !== void 0 ? _a : BrContainerItemUndefined;
    }
    onUpdate() {
        this.forceUpdate((() => this.props.page.sync()));
    }
}

class BrNode extends React.Component {
    renderNode() {
        const {children, component} = this.props;
        if (React.Children.count(children)) {
            return React.createElement(BrMeta, {
                meta: component.getMeta()
            }, children);
        }
        const childrenList = component.getChildren().map(((child, index) => React.createElement(BrNode, {
            key: index,
            component: child
        })));
        if (isContainer(component)) {
            return React.createElement(BrNodeContainer, {
                component,
                page: this.context
            }, childrenList);
        }
        if (isContainerItem(component)) {
            return React.createElement(BrNodeContainerItem, {
                component,
                page: this.context
            }, childrenList);
        }
        return React.createElement(BrNodeComponent, {
            component,
            page: this.context
        }, childrenList);
    }
    render() {
        const {component} = this.props;
        return React.createElement(BrComponentContext.Provider, {
            value: component
        }, this.renderNode());
    }
}

BrNode.contextType = BrPageContext;

/**
 * The brXM component.
 */ class BrComponent extends React.Component {
    getComponents() {
        const {context, props: {path}} = this;
        if (!context) {
            return [];
        }
        if (!path) {
            return context.getChildren();
        }
        const component = context.getComponent(...path.split("/"));
        return component ? [ component ] : [];
    }
    renderComponents() {
        const {children} = this.props;
        return this.getComponents().map(((component, index) => React.createElement(BrNode, {
            key: index,
            component
        }, children)));
    }
    render() {
        return React.createElement(React.Fragment, null, this.renderComponents());
    }
}

BrComponent.contextType = BrComponentContext;

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P((function(resolve) {
            resolve(value);
        }));
    }
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
}

/**
 * @typedef {Object} BrPageProps
 * @property {Configuration} configuration The configuration of the SPA SDK.
 * @property {Object} mapping The brXM and React components mapping.
 * @property {Page | PageModel | undefined} page The pre-initialized page instance or prefetched page model.
 * Mostly this property should be used to transfer state from the server-side to the client-side.
 */
/**
 * The brXM page.
 */ class BrPage extends React.Component {
    /**
     * @param props {BrPageProps}
     */
    constructor(props) {
        super(props);
        this.state = {
            page: props.page && initialize(props.configuration, props.page)
        };
    }
    componentDidMount() {
        const {page} = this.props;
        if (!page) {
            this.initialize();
        }
        const {page: pageInState} = this.state;
        pageInState === null || pageInState === void 0 ? void 0 : pageInState.sync();
    }
    componentDidUpdate(prevProps, prevState) {
        const {configuration, page} = this.props;
        if (configuration !== prevProps.configuration || page !== prevProps.page) {
            this.destroy();
            this.initialize(page === prevProps.page);
        }
        const {page: pageInState} = this.state;
        if (pageInState !== prevState.page) {
            this.forceUpdate((() => pageInState === null || pageInState === void 0 ? void 0 : pageInState.sync()));
        }
    }
    componentWillUnmount() {
        this.destroy();
    }
    initialize(force = false) {
        return __awaiter(this, void 0, void 0, (function*() {
            const {page, configuration} = this.props;
            const model = force ? undefined : page;
            try {
                this.setState({
                    page: model ? initialize(configuration, model) : yield initialize(configuration)
                });
            } catch (error) {
                this.setState((() => {
                    throw error;
                }));
            }
        }));
    }
    destroy() {
        const {page} = this.state;
        if (!page) {
            return;
        }
        destroy(page);
    }
    render() {
        const {page} = this.state;
        if (!page) {
            return null;
        }
        const {mapping, children} = this.props;
        return React.createElement(BrPageContext.Provider, {
            value: page
        }, React.createElement(BrMappingContext.Provider, {
            value: mapping
        }, React.createElement(BrNode, {
            component: page.getComponent()
        }, children)));
    }
}

export { BrComponent, BrComponentContext, BrManageContentButton, BrManageMenuButton, BrPage, BrPageContext };
